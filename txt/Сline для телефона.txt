from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.screenmanager import ScreenManager, Screen
from kivy.uix.scrollview import ScrollView
from kivy.uix.gridlayout import GridLayout
from kivy.uix.textinput import TextInput
from kivy.uix.popup import Popup
from kivy.uix.label import Label
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.widget import Widget
from kivy.properties import (NumericProperty, BooleanProperty, 
                          ObjectProperty, ListProperty, StringProperty)
from kivy.core.window import Window
from kivy.graphics import Color, Rectangle, Line, RoundedRectangle
from kivy.clock import Clock
from kivy.animation import Animation
from kivy.core.text import LabelBase
from kivy.utils import get_color_from_hex
from kivy.config import Config
from kivy.core.image import Image as CoreImage
import sqlite3
import pandas as pd
import os
import datetime
import re
import json
import shutil
from openpyxl import load_workbook, Workbook
from tkinter import Tk, filedialog

LabelBase.register(name='Roboto', 
                 fn_regular='fonts/Roboto-Medium.ttf',
                 fn_bold='fonts/Roboto-Bold.ttf')

class ThemeManager:
    def __init__(self):
        self.themes = []
        self.current_theme_index = 0
        self.themes_dir = 'themes'
        os.makedirs(self.themes_dir, exist_ok=True)
        self.load_themes()
        self.load_config()
        
    def load_themes(self):
        self.themes = []
        self.themes.extend([
            {
                'type': 'color',
                'name': 'light',
                'background': get_color_from_hex('#FEF7FF'),
                'text_color': '#1C1B1F'
            },
            {
                'type': 'color',
                'name': 'dark',
                'background': get_color_from_hex('#1C1B1F'),
                'text_color': '#E6E1E5'
            }
        ])
        
        for file in os.listdir(self.themes_dir):
            if file.lower().endswith(('.png', '.jpg', '.jpeg')):
                self.themes.append({
                    'type': 'image',
                    'name': os.path.splitext(file)[0],
                    'background': os.path.join(self.themes_dir, file),
                    'text_color': '#FFFFFF'
                })
    
    def add_theme(self, image_path):
        dest = os.path.join(self.themes_dir, os.path.basename(image_path))
        shutil.copy(image_path, dest)
        self.load_themes()
    
    @property
    def current_theme(self):
        return self.themes[self.current_theme_index]
    
    def save_config(self):
        config = {
            'theme_index': self.current_theme_index,
            'themes_dir': self.themes_dir
        }
        with open('theme_config.json', 'w') as f:
            json.dump(config, f)
    
    def load_config(self):
        try:
            with open('theme_config.json', 'r') as f:
                config = json.load(f)
                self.current_theme_index = config.get('theme_index', 0)
                self.themes_dir = config.get('themes_dir', 'themes')
        except (FileNotFoundError, json.JSONDecodeError):
            self.current_theme_index = 0

class ModernButton(Button):
    bg_color = ListProperty([1, 1, 1, 1])
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.background_color = (0, 0, 0, 0)
        self.font_name = 'Roboto'
        self.font_size = '16sp'
        self.bold = False
        self.size_hint = (None, None)
        self.height = 50
        self.padding = (20, 5)
        
        with self.canvas.before:
            Color(rgba=(0, 0, 0, 0.1))
            self.shadow = RoundedRectangle(
                pos=(self.x+3, self.y-3), 
                size=self.size,
                radius=[10]
            )
            self.bg_color_instruction = Color(rgba=self.bg_color)
            self.background = RoundedRectangle(
                pos=self.pos, 
                size=self.size,
                radius=[10]
            )

        self.bind(pos=self.update_graphics, size=self.update_graphics)
        self.bind(text=self.update_width)

    def update_width(self, instance, value):
        self.width = self.texture_size[0] + 60

    def update_graphics(self, *args):
        self.background.pos = self.pos
        self.shadow.pos = (self.x+3, self.y-3)
        self.background.size = self.size
        self.shadow.size = self.size

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            Animation(rgba=[c * 0.9 for c in self.bg_color], d=0.1).start(self.bg_color_instruction)
        return super().on_touch_down(touch)

    def on_touch_up(self, touch):
        Animation(rgba=self.bg_color, d=0.2).start(self.bg_color_instruction)
        return super().on_touch_up(touch)

class AutoCompleteTextInput(TextInput):
    next_widget = ObjectProperty(None)
    prev_widget = ObjectProperty(None)
    row_index = NumericProperty(0)
    col_index = NumericProperty(0)
    suggestions = ListProperty([])
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.bind(text=self.show_suggestions)
        self.popup = None

    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        key = keycode[1]
        if key == 'down':
            self.focus_next('down')
        elif key == 'up':
            self.focus_previous('up')
        elif key == 'right':
            self.focus_next('right')
        elif key == 'left':
            self.focus_previous('left')
        else:
            super().keyboard_on_key_down(window, keycode, text, modifiers)
        return True

    def show_suggestions(self, instance, value):
        if self.popup:
            self.popup.dismiss()
        if not value or len(value) < 2:
            return
            
        conn = sqlite3.connect('forest_data.db')
        cursor = conn.cursor()
        cursor.execute('''
            SELECT value FROM suggestions 
            WHERE column_index = ? AND value LIKE ?
            ORDER BY LENGTH(value) ASC, value ASC
            LIMIT 10
        ''', (self.col_index, f'{value}%'))
        results = cursor.fetchall()
        conn.close()
        
        self.suggestions = [item[0] for item in results]
        
        if self.suggestions:
            # Определяем, находимся ли мы на мобильном устройстве
            is_mobile = Window.height > Window.width
            
            layout = GridLayout(
                cols=1, 
                spacing=10,  # Увеличиваем расстояние между кнопками
                size_hint_y=None,
                padding=[10, 10, 10, 10]  # Добавляем отступы
            )
            layout.bind(minimum_height=layout.setter('height'))
            
            for suggestion in self.suggestions:
                btn = ModernButton(
                    text=suggestion, 
                    size_hint_y=None, 
                    height=50 if is_mobile else 40,  # Увеличиваем высоту кнопок на мобильных
                    bg_color=(1, 0, 0, 1),
                    color=(0, 0, 0, 1),
                    font_size='16sp'  # Увеличиваем размер шрифта
                )
                # Сохраняем текст кнопки в отдельном атрибуте для использования в обработчике
                btn.suggestion_text = suggestion
                btn.bind(on_release=self._on_suggestion_selected)
                layout.add_widget(btn)
            
            # Создаем ScrollView для прокрутки, если много вариантов
            scroll = ScrollView(size_hint=(1, None), height=300 if is_mobile else 200)
            scroll.add_widget(layout)
            
            self.popup = Popup(
                title='Выберите вариант',
                content=scroll,
                size_hint=(0.9, None) if is_mobile else (0.6, None),  # Шире на мобильных
                height=350 if is_mobile else 250,
                pos_hint={'center_x': 0.5, 'center_y': 0.5}
            )
            self.popup.open()

    def get_table_screen(self):
        return App.get_running_app().root.get_screen('table')

    def focus_next(self, direction):
        table_screen = self.get_table_screen()
        if direction == 'right' and self.next_widget:
            self.next_widget.focus = True
        elif direction == 'down':
            next_row = self.row_index + 1
            if next_row < len(table_screen.inputs):
                table_screen.inputs[next_row][self.col_index].focus = True

    def focus_previous(self, direction):
        table_screen = self.get_table_screen()
        if direction == 'left' and self.prev_widget:
            self.prev_widget.focus = True
        elif direction == 'up':
            prev_row = self.row_index - 1
            if prev_row >= 0:
                table_screen.inputs[prev_row][self.col_index].focus = True
                
    def _on_suggestion_selected(self, button):
        """Обработчик выбора варианта из списка подсказок"""
        self.text = button.suggestion_text
        if self.popup:
            self.popup.dismiss()

class Joypad(FloatLayout):
    def __init__(self, table_screen, **kwargs):
        super().__init__(**kwargs)
        self.table_screen = table_screen
        self.size_hint = (None, None)
        self.size = (160, 160)  # Увеличиваем размер для лучшего касания
        self.pos_hint = {'center_x': 0.5, 'center_y': 0.5}  # Центрируем джойстик
        
        with self.canvas.before:
            Color(0.2, 0.2, 0.2, 0.8)  # Делаем фон полупрозрачным
            self.bg_rect = RoundedRectangle(
                pos=self.pos,
                size=self.size,
                radius=[80]  # Увеличиваем радиус для более круглой формы
            )
        
        # Увеличиваем размер кнопок для лучшего касания
        arrows = [
            ('▲', (0.5, 0.75), 'up', (70, 50)),
            ('▼', (0.5, 0.25), 'down', (70, 50)),
            ('◄', (0.25, 0.5), 'left', (50, 70)),
            ('►', (0.75, 0.5), 'right', (50, 70))
        ]
        
        for symbol, pos, direction, size in arrows:
            btn = ModernButton(
                text=symbol,
                size_hint=(None, None),
                size=size,
                pos_hint={'center_x': pos[0], 'center_y': pos[1]},
                bg_color=(0.1, 0.1, 0.1, 0.9),  # Делаем кнопки полупрозрачными
                color=(1, 1, 1, 1),
                font_size='24sp',  # Увеличиваем размер шрифта
                bold=True
            )
            btn.bind(on_press=lambda x, d=direction: self.move_focus(d))
            self.add_widget(btn)

        self.bind(pos=self.update_bg, size=self.update_bg)

    def update_bg(self, *args):
        self.bg_rect.pos = self.pos
        self.bg_rect.size = self.size

    def move_focus(self, direction):
        current = self.table_screen.focused_cell
        if not current: return
        row, col = current
        
        if direction == 'up': row = max(0, row-1)
        elif direction == 'down': row = min(len(self.table_screen.inputs)-1, row+1)
        elif direction == 'left': col = max(0, col-1)
        elif direction == 'right': col = min(8, col+1)
        
        self.table_screen.focused_cell = [row, col]
        inp = self.table_screen.inputs[row][col]
        inp.focus = True
        inp.cursor = (len(inp.text), 0)
        Clock.schedule_once(lambda dt: self._update_cursor(inp), 0.01)

    def _update_cursor(self, inp):
        inp.focus = True
        inp.cursor = (len(inp.text), 0)
        inp.text = inp.text

class ExitConfirmPopup(Popup):
    def __init__(self, **kwargs):
        # Определяем, находимся ли мы на мобильном устройстве
        is_mobile = Window.height > Window.width
        
        super().__init__(
            title='',
            separator_height=0,
            size_hint=(0.8, 0.4) if is_mobile else (0.5, 0.35),  # Шире на мобильных
            background='',
            overlay_color=(0, 0, 0, 0.5)
        )
        
        content = BoxLayout(
            orientation='vertical',
            spacing=20,  # Увеличиваем расстояние между элементами
            padding=30 if is_mobile else 20  # Больше отступы на мобильных
        )
        
        with content.canvas.before:
            Color(0.98, 0.98, 0.98, 1)
            RoundedRectangle(
                pos=content.pos,
                size=content.size,
                radius=[40]
            )
        
        content.add_widget(Label(
            text='Вы уверены, что хотите выйти?',
            font_name='Roboto',
            font_size='20sp' if is_mobile else '18sp',  # Увеличиваем шрифт на мобильных
            color=(0.2, 0.2, 0.2, 1),
            halign='center',
            size_hint_y=None,
            height=60 if is_mobile else 50
        ))
        
        # Для мобильных делаем кнопки в столбик для удобства нажатия
        btn_box = BoxLayout(
            orientation='vertical' if is_mobile else 'horizontal',
            spacing=15,
            size_hint_y=None,
            height=130 if is_mobile else 60
        )
        
        yes_btn = ModernButton(
            text='Выход',
            bg_color=(1, 0, 0, 1),
            color=(0, 0, 0, 1),
            size_hint=(1, None) if is_mobile else (0.5, None),
            height=60 if is_mobile else 45,
            font_size='18sp' if is_mobile else '16sp'
        )
        
        no_btn = ModernButton(
            text='Отмена',
            bg_color=(1, 0, 0, 1),
            color=(0, 0, 0, 1),
            size_hint=(1, None) if is_mobile else (0.5, None),
            height=60 if is_mobile else 45,
            font_size='18sp' if is_mobile else '16sp'
        )
        
        yes_btn.bind(on_press=lambda x: App.get_running_app().stop())
        no_btn.bind(on_press=self.dismiss)
        
        # На мобильных сначала кнопка "Отмена", потом "Выход" (снизу вверх)
        if is_mobile:
            btn_box.add_widget(no_btn)
            btn_box.add_widget(yes_btn)
        else:
            btn_box.add_widget(yes_btn)
            btn_box.add_widget(no_btn)
            
        content.add_widget(btn_box)
        
        self.content = content

class MainMenu(Screen):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.bg_image = None
        self.bg_rect = None
        self.setup_ui()
        
    def setup_ui(self):
        self.clear_widgets()
        theme = App.get_running_app().theme_manager.current_theme
        
        with self.canvas.before:
            if theme['type'] == 'color':
                Color(rgba=theme['background'])
                self.bg_rect = Rectangle(pos=self.pos, size=self.size)
            else:
                self.bg_image = CoreImage(theme['background']).texture
                self.bg_rect = Rectangle(
                    texture=self.bg_image,
                    pos=self.pos,
                    size=self.size
                )
            
        self.bind(pos=self.update_bg, size=self.update_bg)
        
        main_layout = BoxLayout(orientation='vertical', padding=20)
        
        center_layout = BoxLayout(
            orientation='vertical',
            size_hint=(0.8, None),
            height=400,
            pos_hint={'center_x': 0.5, 'center_y': 0.75},
            spacing=15
        )
        
        title = Label(
            text='Фанаты Пихты',
            font_size='24sp',
            font_name='Roboto',
            size_hint_y=None,
            height=60
        )
        center_layout.add_widget(title)
        
        buttons = [
            ('Сменить тему', '#00FF00', self.change_theme),
            ('Перечётная ведомость', '#FFA500', self.show_add_section),
            ('Выбрать тему', '#FFFF00', self.show_theme_chooser),
            ('Выход', '#FF0000', self.confirm_exit)
        ]
        
        for text, color, callback in buttons:
            btn = ModernButton(
                text=text,
                bg_color=get_color_from_hex(color),
                color=get_color_from_hex('#000000'),
                size_hint=(None, None),
                size=(250, 50),
                pos_hint={'center_x': 0.5}
            )
            btn.bind(on_press=callback)
            center_layout.add_widget(btn)
        
        main_layout.add_widget(center_layout)
        
        footer = Label(
            text='by forestcrypt®',
            font_size='12sp',
            color=(1, 1, 1, 1),
            size_hint=(1, None),
            height=30,
            pos_hint={'right': 0.98, 'y': 0.02}
        )
        main_layout.add_widget(footer)
        
        self.add_widget(main_layout)
        
    def update_bg(self, *args):
        if self.bg_rect:
            self.bg_rect.pos = self.pos
            self.bg_rect.size = self.size
            
    def change_theme(self, instance):
        themes = App.get_running_app().theme_manager.themes
        current_idx = App.get_running_app().theme_manager.current_theme_index
        new_idx = (current_idx + 1) % len(themes)
        App.get_running_app().theme_manager.current_theme_index = new_idx
        App.get_running_app().theme_manager.save_config()
        App.get_running_app().reload_theme()

    def show_theme_chooser(self, instance):
        ThemeChooser().open()

    def show_add_section(self, instance):
        content = BoxLayout(orientation='vertical', spacing=10)
        
        with content.canvas.before:
            Color(rgba=(0.9, 0.9, 0.9, 1))
            RoundedRectangle(
                pos=content.pos,
                size=content.size,
                radius=[20]
            )
        
        self.section_number_input = TextInput(
            hint_text="Введите номер участка",
            multiline=False,
            size_hint_y=None,
            height=40,
            background_color=(1, 1, 1, 0.8)
        )
        
        btn_box = BoxLayout(spacing=10, size_hint_y=None, height=50)
        buttons = [
            ('Добавить', '#00FF00', self.add_section),
            ('Сохранить', '#0000FF', self.save_section),
            ('Отмена', '#FF0000', lambda x: self.section_popup.dismiss())
        ]
        
        for text, color, callback in buttons:
            btn = ModernButton(
                text=text,
                bg_color=get_color_from_hex(color),
                size_hint=(0.33, None),
                height=45
            )
            btn.bind(on_press=callback)
            btn_box.add_widget(btn)
        
        content.add_widget(self.section_number_input)
        content.add_widget(btn_box)

        self.section_popup = Popup(
            title="Управление участками",
            content=content,
            size_hint=(0.7, 0.4),
            separator_height=0,
            background='',
            overlay_color=(0, 0, 0, 0.5)
        )
        self.section_popup.open()

    def add_section(self, instance):
        try:
            conn = sqlite3.connect('forest_data.db')
            cursor = conn.cursor()
            cursor.execute('INSERT INTO sections DEFAULT VALUES')
            conn.commit()
            self.show_success("Новый участок создан!")
        except Exception as e:
            self.show_error(f"Ошибка: {str(e)}")
        finally:
            conn.close()

    def save_section(self, instance):
        section_number = self.section_number_input.text.strip()
        if not section_number:
            self.show_error("Введите номер участка!")
            return
            
        try:
            conn = sqlite3.connect('forest_data.db')
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE sections 
                SET section_number = ? 
                WHERE id = (SELECT MAX(id) FROM sections)
            ''', (section_number,))
            conn.commit()
            self.section_popup.dismiss()
            App.get_running_app().root.get_screen('table').current_section = section_number
            App.get_running_app().root.get_screen('table').update_section_label()
            App.get_running_app().root.current = 'table'
        except Exception as e:
            self.show_error(f"Ошибка сохранения: {str(e)}")
        finally:
            conn.close()

    def confirm_exit(self, instance):
        ExitConfirmPopup().open()

    def show_success(self, message):
        Popup(
            title='Успешно',
            content=Label(
                text=message, 
                color=(0, 0.5, 0, 1), 
                font_name='Roboto'
            ),
            size_hint=(0.6, 0.3)
        ).open()

    def show_error(self, message):
        Popup(
            title='Ошибка',
            content=Label(
                text=message, 
                color=(1, 0, 0, 1), 
                font_name='Roboto'
            ),
            size_hint=(0.6, 0.3)
        ).open()

class TableScreen(Screen):
    current_page = NumericProperty(0)
    total_pages = NumericProperty(1)
    unsaved_changes = BooleanProperty(False)
    focused_cell = ListProperty([0, 0])
    edit_mode = BooleanProperty(False)
    current_section = StringProperty("")
    MAX_PAGES = 200

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.theme_manager = App.get_running_app().theme_manager
        self.reports_dir = "reports"
        os.makedirs(self.reports_dir, exist_ok=True)
        self.db_name = 'forest_data.db'
        self.rows_per_page = 50
        self.page_data = {}
        self.setup_database()
        self.create_ui()
        self.load_existing_data()
        Window.bind(on_key_down=self.key_action)

    def key_action(self, window, key, scancode, codepoint, modifier):
        if key == 115 and 'ctrl' in modifier:
            self.validate_and_save(None)

    def setup_database(self):
        conn = sqlite3.connect(self.db_name)
        cursor = conn.cursor()
        cursor.execute('''CREATE TABLE IF NOT EXISTS trees (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        tree_number INTEGER,
                        species TEXT,
                        age TEXT,
                        count TEXT,
                        diameter REAL,
                        height REAL,
                        condition TEXT,
                        model TEXT,
                        notes TEXT,
                        section_id INTEGER,
                        FOREIGN KEY(section_id) REFERENCES sections(id))''')
        
        cursor.execute('''CREATE TABLE IF NOT EXISTS sections (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        section_number TEXT UNIQUE,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
        
        cursor.execute('''CREATE TABLE IF NOT EXISTS suggestions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        column_index INTEGER,
                        value TEXT,
                        UNIQUE(column_index, value))''')
        
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_suggestions ON suggestions (column_index, value)')
        conn.commit()
        conn.close()

    def create_ui(self):
        # Определяем ориентацию в зависимости от размера экрана
        # На мобильных устройствах обычно высота > ширины
        is_mobile = Window.height > Window.width
        
        # Основной контейнер - вертикальный для мобильных, горизонтальный для десктопа
        main_layout = BoxLayout(
            orientation='vertical' if is_mobile else 'horizontal', 
            padding=10, 
            spacing=10
        )
        
        with self.canvas.before:
            self.bg_color = Color(1, 1, 1, 1)
            self.bg_rect = Rectangle(pos=self.pos, size=self.size)
            self.bind(pos=self._update_bg, size=self._update_bg)
        
        self._update_background(self.theme_manager.current_theme)

        # Заголовок участка - всегда вверху
        header_layout = BoxLayout(orientation='vertical', size_hint_y=None, height=40)
        self.section_label = Label(
            text=f"Участок: {self.current_section}", 
            font_name='Roboto',
            size_hint=(1, None),
            height=40,
            color=self._get_text_color(),
            font_size='16sp'
        )
        header_layout.add_widget(self.section_label)
        main_layout.add_widget(header_layout)
        
        # Создаем контейнер для таблицы и контролов
        content_layout = BoxLayout(
            orientation='vertical' if is_mobile else 'horizontal',
            spacing=10
        )
        
        # Табличная часть
        table_panel = BoxLayout(
            orientation='vertical', 
            size_hint_x=1 if is_mobile else 0.7,
            size_hint_y=0.7 if is_mobile else 1
        )
        
        # Пагинация
        pagination = BoxLayout(size_hint_y=None, height=50, spacing=5)
        self.page_label = Label(
            text=f'Страница {self.current_page+1} из {self.total_pages}', 
            size_hint_x=0.4, 
            font_name='Roboto',
            color=self._get_text_color(),
            font_size='14sp'
        )
        prev_btn = ModernButton(
            text='← Пред', 
            size_hint_x=0.3,
            bg_color=get_color_from_hex('#00FF00'),
            color=self._get_text_color(),
            height=50
        )
        prev_btn.bind(on_press=lambda x: self.change_page(-1))
        next_btn = ModernButton(
            text='След →', 
            size_hint_x=0.3,
            bg_color=get_color_from_hex('#00FF00'),
            color=self._get_text_color(),
            height=50
        )
        next_btn.bind(on_press=lambda x: self.change_page(1))
        pagination.add_widget(prev_btn)
        pagination.add_widget(self.page_label)
        pagination.add_widget(next_btn)
        table_panel.add_widget(pagination)
        
        # Основная таблица
        scroll = ScrollView(do_scroll_x=True, do_scroll_y=True, bar_width=10)
        self.table = GridLayout(cols=9, size_hint=(None, None), spacing=2)
        self.table.bind(minimum_height=self.table.setter('height'), 
                       minimum_width=self.table.setter('width'))
        
        # Заголовки столбцов
        headers = ['№ дерева*', 'Порода*', 'ж/ф', 'шт/либо лет',
                 'D, см*', 'H, м', 'Сост-е', 'Модель', 'Примечания']
        for header in headers:
            lbl = Label(
                text=header,
                size_hint_y=None,
                height=40,  # Увеличиваем высоту для лучшего касания
                font_name='Roboto',
                bold=True,
                halign='center',
                size_hint_x=None,
                width=100,
                color=self._get_text_color(),
                font_size='14sp'
            )
            self.table.add_widget(lbl)
        
        # Создаем строки таблицы
        self.inputs = []
        for row_idx in range(self.rows_per_page):
            row = []
            for col_idx in range(9):
                inp = AutoCompleteTextInput(
                    multiline=False, 
                    size_hint_y=None, 
                    height=40,  # Увеличиваем высоту для лучшего касания
                    font_size='14sp'
                )
                inp.row_index = row_idx
                inp.col_index = col_idx
                inp.bind(focus=self.update_focus)
                inp.font_name = 'Roboto'
                
                if col_idx > 0:
                    inp.prev_widget = row[col_idx-1] if row else None
                    if row:
                        row[col_idx-1].next_widget = inp
                if row_idx > 0:
                    inp.prev_widget = self.inputs[row_idx-1][col_idx] if self.inputs else None
                    if self.inputs:
                        self.inputs[row_idx-1][col_idx].next_widget = inp
                
                if col_idx in [0,4,5]:
                    inp.input_filter = 'float' if col_idx in [4,5] else 'int'
                if col_idx == 0:
                    inp.bind(focus=self.auto_fill_tree_number)
                row.append(inp)
                self.table.add_widget(inp)
            self.inputs.append(row)
        
        scroll.add_widget(self.table)
        table_panel.add_widget(scroll)
        content_layout.add_widget(table_panel)
        
        # Панель управления
        control_panel = BoxLayout(
            orientation='vertical', 
            size_hint_x=1 if is_mobile else 0.3,
            size_hint_y=0.3 if is_mobile else 1,
            spacing=10,
            padding=[10, 10, 10, 10]
        )
        
        # Кнопки управления
        controls_scroll = ScrollView(do_scroll_x=False, do_scroll_y=True)
        controls = GridLayout(
            cols=2 if is_mobile else 1,
            spacing=10,
            size_hint_y=None
        )
        controls.bind(minimum_height=controls.setter('height'))
        
        button_handlers = {
            'Сохранить отчет': self.show_save_dialog,
            'Сохранить страницу': self.save_current_page,
            'Загрузить участок': self.load_section,
            'Открыть папку': self.open_excel_file,
            'Редакт. режим': self.toggle_edit_mode,
            'Очистить данные': self.clear_table_data,
            'В главное меню': self.go_back
        }
        
        button_colors = {
            'Сохранить отчет': '#00FF00',
            'Сохранить страницу': '#00FFFF',
            'Загрузить участок': '#006400',
            'Открыть папку': '#0000FF',
            'Редакт. режим': '#FFA500',
            'Очистить данные': '#800000',
            'В главное меню': '#FF0000'
        }
        
        for text, color in button_colors.items():
            btn = ModernButton(
                text=text,
                bg_color=get_color_from_hex(color),
                size_hint_y=None,
                height=60,  # Увеличиваем высоту для лучшего касания
                font_size='16sp'
            )
            if is_mobile:
                btn.size_hint_x = 0.5
            else:
                btn.size_hint_x = None
                btn.width = 220
                btn.pos_hint = {'center_x': 0.5}
            
            btn.bind(on_press=button_handlers[text])
            controls.add_widget(btn)
        
        controls_scroll.add_widget(controls)
        control_panel.add_widget(controls_scroll)
        
        # Джойстик
        joypad_container = BoxLayout(
            size_hint_y=None, 
            height=160,
            padding=[0, 10, 0, 10]
        )
        
        joypad = Joypad(self)
        joypad.size = (160, 160)  # Увеличиваем размер для лучшего касания
        joypad.pos_hint = {'center_x': 0.5, 'center_y': 0.5}
        joypad_container.add_widget(joypad)
        
        control_panel.add_widget(joypad_container)
        content_layout.add_widget(control_panel)
        
        main_layout.add_widget(content_layout)
        self.add_widget(main_layout)

    def _update_bg(self, instance, value):
        self.bg_rect.pos = self.pos
        self.bg_rect.size = self.size

    def _update_background(self, theme):
        if theme['type'] == 'image':
            try:
                self.bg_color.rgba = (1, 1, 1, 1)
                self.bg_rect.texture = CoreImage(theme['background']).texture
            except Exception as e:
                print(f"Error loading background image: {str(e)}")
        else:
            self.bg_color.rgba = theme['background']
            self.bg_rect.texture = None

    def _get_text_color(self):
        theme = self.theme_manager.current_theme
        if theme['type'] == 'image':
            return get_color_from_hex('#FFFFFF')
        else:
            return get_color_from_hex(theme['text_color'])

    def update_section_label(self):
        self.section_label.text = f"Участок: {self.current_section}"

    def toggle_edit_mode(self, instance):
        self.edit_mode = not self.edit_mode
        theme = self.theme_manager.current_theme
        instance.bg_color = get_color_from_hex('#FFA500' if self.edit_mode else '#00FF00')

    def update_focus(self, instance, value):
        if value:
            self.focused_cell = [instance.row_index, instance.col_index]

    def auto_fill_tree_number(self, instance, value):
        if self.edit_mode: return
        if value and instance.focus:
            try:
                current_number = int(instance.text)
            except ValueError:
                current_number = 0
            for row_idx, row in enumerate(self.inputs):
                if row_idx > instance.row_index:
                    try:
                        prev_num = int(self.inputs[row_idx-1][0].text)
                        row[0].text = str(prev_num + 1)
                    except (ValueError, IndexError):
                        pass

    def validate_and_save(self, instance):
        error = False
        new_data = []
        error_fields = []
        
        for row in self.inputs:
            row_data = [inp.text.strip() for inp in row]
            if any(row_data):
                errors = []
                if not row_data[0].isdigit():
                    errors.append(0)
                if not row_data[1]:
                    errors.append(1)
                if not self.is_valid_number(row_data[4]):
                    errors.append(4)
                if errors:
                    error = True
                    error_fields.extend([(row, col) for col in errors])
                else:
                    new_data.append(row_data)
        
        if error:
            self.highlight_errors(error_fields)
            self.show_error("Обязательные поля не заполнены или содержат ошибки!")
            return
        
        if new_data:
            self.save_to_database(new_data)
            self.save_current_page(instance)
            self.unsaved_changes = False
            self.show_success("Данные сохранены успешно!")
            self.update_pagination()
        else:
            self.show_error("Нет данных для сохранения!")

    def save_current_page(self, instance=None):
        page_data = []
        for row in self.inputs:
            page_data.append([inp.text for inp in row])
        self.page_data[self.current_page] = page_data

    def show_save_dialog(self, instance=None):
        content = BoxLayout(orientation='vertical', spacing=10)
        self.filename_input = TextInput(hint_text="Имя файла", multiline=False)
        default_name = f"{self.current_section}_{datetime.datetime.now().strftime('%Y-%m-%d_%H-%M')}"
        self.filename_input.text = default_name
        btn_box = BoxLayout(spacing=5)
        ok_btn = ModernButton(text="Сохранить", size_hint=(0.5, None), height=40)
        cancel_btn = ModernButton(text="Отмена", size_hint=(0.5, None), height=40)
        btn_box.add_widget(ok_btn)
        btn_box.add_widget(cancel_btn)
        content.add_widget(Label(text="Введите имя файла:"))
        content.add_widget(self.filename_input)
        content.add_widget(btn_box)
        self.save_popup = Popup(
            title="Сохранение отчета",
            content=content,
            size_hint=(0.7, 0.4)
        )
        ok_btn.bind(on_press=self.save_to_excel)
        cancel_btn.bind(on_press=self.save_popup.dismiss)
        self.save_popup.open()

    def save_to_excel(self, instance):
        filename = self.filename_input.text.strip()
        if not filename:
            self.show_error("Имя файла не может быть пустым!")
            return
        filename = re.sub(r'[\\/*?:"<>|]', "", filename)
        filename = f"{filename}.xlsx" if not filename.endswith(".xlsx") else filename
        full_path = os.path.join(self.reports_dir, filename)
        
        try:
            all_data = []
            for page in sorted(self.page_data.keys()):
                all_data.extend(self.page_data[page])
            df = pd.DataFrame(
                all_data,
                columns=['№ дерева','Порода','ж/ф','шт/либо лет','D, см','H, м','Сост-е','Модель','Примечания']
            )
            df.to_excel(full_path, index=False)
            self.save_popup.dismiss()
            self.show_success(f"Файл сохранен: {filename}")
        except Exception as e:
            self.show_error(f"Ошибка: {str(e)}")

    def load_section(self, instance):
        Tk().withdraw()
        file_path = filedialog.askopenfilename(
            initialdir=self.reports_dir,
            title="Выберите файл участка",
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        if file_path:
            try:
                df = pd.read_excel(file_path)
                data = df.values.tolist()
                self.save_to_database(data)
                
                self.current_section = os.path.splitext(os.path.basename(file_path))[0]
                self.update_section_label()
                self.page_data.clear()
                
                for page_num in range(0, len(df), self.rows_per_page):
                    page = page_num // self.rows_per_page
                    page_data = df.iloc[page_num:page_num+self.rows_per_page].values.tolist()
                    self.page_data[page] = page_data
                
                self.current_page = 0
                self.load_page_data()
                self.update_pagination()
                self.show_success("Данные успешно загружены!")
            except Exception as e:
                self.show_error(f"Ошибка загрузки: {str(e)}")

    def load_page_data(self):
        for row in self.inputs:
            for inp in row:
                inp.unbind(text=inp.show_suggestions)
        
        for row in self.inputs:
            for inp in row:
                inp.text = ''
        
        if self.current_page in self.page_data:
            for i, row_data in enumerate(self.page_data[self.current_page]):
                if i >= len(self.inputs):
                    break
                for j, text in enumerate(row_data):
                    if j < len(self.inputs[i]):
                        self.inputs[i][j].text = str(text) if not pd.isna(text) else ''
        
        for row in self.inputs:
            for inp in row:
                inp.bind(text=inp.show_suggestions)

    def clear_table_data(self, instance=None):
        for row in self.inputs:
            for inp in row:
                inp.text = ''
        self.page_data.clear()
        self.show_success("Данные очищены!")

    def highlight_errors(self, error_fields):
        for row, col in error_fields:
            row[col].background_color = (1, 0.8, 0.8, 1)

    def is_valid_number(self, value):
        try:
            float(value)
            return True
        except ValueError:
            return False

    def save_to_database(self, data):
        conn = sqlite3.connect(self.db_name)
        cursor = conn.cursor()
        
        try:
            cursor.execute('SELECT id FROM sections WHERE section_number = ?', (self.current_section,))
            section_id = cursor.fetchone()[0]
            
            for row in data:
                cursor.execute('''INSERT OR REPLACE INTO trees 
                               (tree_number, species, age, count, diameter, height, 
                               condition, model, notes, section_id)
                               VALUES (?,?,?,?,?,?,?,?,?,?)''',
                               (row[0], row[1], row[2], row[3], row[4], row[5], 
                                row[6], row[7], row[8], section_id))
                
                for col_idx in [1, 2, 8]:
                    value = row[col_idx]
                    if value:
                        cursor.execute('INSERT OR IGNORE INTO suggestions (column_index, value) VALUES (?, ?)',
                                      (col_idx, value))
            
            conn.commit()
            self.show_success("Данные успешно сохранены в базе!")
        except Exception as e:
            self.show_error(f"Ошибка сохранения: {str(e)}")
            conn.rollback()
        finally:
            conn.close()

    def open_excel_file(self, instance):
        if os.path.exists(self.reports_dir):
            os.startfile(self.reports_dir)
        else:
            self.show_error("Папка reports не найдена!")

    def change_page(self, delta):
        new_page = self.current_page + delta
        if 0 <= new_page < self.MAX_PAGES:
            self.current_page = new_page
            self.load_page_data()
            self.update_page_label()

    def update_pagination(self):
        self.total_pages = len(self.page_data) if self.page_data else 1
        self.total_pages = min(self.total_pages, self.MAX_PAGES)
        self.update_page_label()

    def update_page_label(self):
        self.page_label.text = f'Страница {self.current_page+1} из {self.total_pages}'

    def go_back(self, instance):
        if self.unsaved_changes:
            self.show_confirm_dialog()
        else:
            App.get_running_app().root.current = 'main'

    def show_error(self, message):
        Popup(
            title='Ошибка',
            content=Label(text=message, color=(1, 0, 0, 1)),
            size_hint=(0.6, 0.3)
        ).open()

    def show_success(self, message):
        Popup(
            title='Успешно',
            content=Label(text=message, color=(0, 0.5, 0, 1)),
            size_hint=(0.6, 0.3)
        ).open()
        
    def load_existing_data(self):
        pass

class ThemeChooser(Popup):
    def __init__(self, **kwargs):
        super().__init__(title='Выбор темы', size_hint=(0.9, 0.8))
        self.layout = GridLayout(cols=3, spacing=10, padding=10)
        self.scroll = ScrollView()
        
        for theme in App.get_running_app().theme_manager.themes:
            btn = Button(size_hint=(None, None), size=(200, 200))
            if theme['type'] == 'color':
                btn.background_color = theme['background']
            else:
                btn.background_normal = theme['background']
            btn.bind(on_release=lambda x, t=theme: self.select_theme(t))
            self.layout.add_widget(btn)
        
        add_btn = Button(text='Добавить тему', size_hint=(None, None), size=(200, 200))
        add_btn.bind(on_release=self.add_theme)
        self.layout.add_widget(add_btn)
        
        self.scroll.add_widget(self.layout)
        self.content = self.scroll

    def select_theme(self, theme):
        manager = App.get_running_app().theme_manager
        manager.current_theme_index = manager.themes.index(theme)
        manager.save_config()
        App.get_running_app().reload_theme()
        self.dismiss()

    def add_theme(self, instance):
        Tk().withdraw()
        file_path = filedialog.askopenfilename(
            filetypes=[("Image files", "*.jpg *.jpeg *.png")]
        )
        if file_path:
            App.get_running_app().theme_manager.add_theme(file_path)
            self.layout.clear_widgets()
            for theme in App.get_running_app().theme_manager.themes:
                btn = Button(size_hint=(None, None), size=(200, 200))
                if theme['type'] == 'color':
                    btn.background_color = theme['background']
                else:
                    btn.background_normal = theme['background']
                btn.bind(on_release=lambda x, t=theme: self.select_theme(t))
                self.layout.add_widget(btn)
            
            # Create a new add button
            new_add_btn = Button(text='Добавить тему', size_hint=(None, None), size=(200, 200))
            new_add_btn.bind(on_release=self.add_theme)
            self.layout.add_widget(new_add_btn)

class ForestryApp(App):
    theme_manager = ThemeManager()
    
    def build(self):
        Config.set('graphics', 'multisamples', '4')
        self.apply_theme()
        sm = ScreenManager()
        sm.add_widget(MainMenu(name='main'))
        sm.add_widget(TableScreen(name='table'))
        return sm
    
    def apply_theme(self):
        theme = self.theme_manager.current_theme
        if theme['type'] == 'image':
            Window.clearcolor = (1, 1, 1, 1)
        else:
            Window.clearcolor = theme['background']
    
    def reload_theme(self):
        self.apply_theme()
        for screen in self.root.screens:
            if hasattr(screen, 'setup_ui'):
                screen.setup_ui()
            for widget in screen.walk():
                if isinstance(widget, ModernButton) and screen.name == 'table':
                    widget.color = screen._get_text_color()

if __name__ == '__main__':
    ForestryApp().run()
